# asynchrony


### 4_Generators

__Генератор__ - это функция.
   

> ### Пример с перебором букв в слове

```
def gen():
    name = 'Bob'
    for i in name:
        yield i
        
g = gen()
next(g)
>>> B
next(g)
>>> o
next(g)
>>> b
next(g)
>>> Error ... StopIteration
```
Как только генератор "истощается/заканчивается" он выбрасывает ошибку.  
     
> ### Пример с созданием папок

```
from time import time

def gen_file_name():
    while True:
        pattern = 'file-{}'
        t = int(time() * 1000)
        file_name = pattern.format(str(t))
        yield file_name

g = gen_file_name()
next(g)
>>> file-1584695786887
next(g)
>>> file-1584695786759
```
В этом примере генератор не закончиться потому, что внутри него крутиться бесконечный цикл _while True_.  
     
> ### Инструкции yield в одной функции-генераторе может быть несколько.

В то время как у _функции_ весь код, который идет после _**return**_ не выполняется. У _генератора_ всё совсем ___не так___.
```
def gen_file_name():
    while True:
        pattern = 'file-{}'
        t = int(time() * 1000)
        file_name = pattern.format(str(t))
        yield file_name                     # точка остановки

        sum = 123 + 321
        print(sum)
        
g = gen_file_name()
next(g)
>>> file-1584695786887
next(g)
>>> 444                                     # вот это важный момент
>>> file-1584695786759
```
Т.е. что получается? При вызове функции next(), генератор отрабатывает до yield (точка остановки) и засыпает. 
После повторного вызова функции next(), оставщаяся часть генератора выполняется, т.е. печатает нам сумму и 
начинается новая итерация цикла.

     
     
### Событийный цикл _Round Robin_

Мы построили бассейн и в нём нету воды, в то время как у наших соседей в бассейне есть вода. Мы собрали всех друзей, дали каждому
по ведру и построили их в очередь. Первый в очереди зачерпывает воду в ведро, несёт воду к нам в бассейн, вылевает её и встаёт в 
конец очереди. Тот кто был вторым в очереди, становится первым и проделывает тоже самое. И цикличность продолжается пока работа не 
будет выполнена. Вот это и есть _Round Robin, карусель._ 

```
def gen1(n):
    for i in range(n):
        yield i

def gen2(string):
    for el in string:
        yield el

g1 = gen1(3)
g2 = gen2('Bob')

tasks = [g1, g2]

while tasks:
    try:
        task = tasks.pop(0)
        next(task)
        tasks.append(task)
    except StopIteration:
        pass

>>> 0
>>> B
>>> 1
>>> o
>>> 2
>>> b
```
Суть в том что генераторы выполнялись строго по очереди, каждый раз передавая конкроль туда где вызывалась функция _next_.
После каждого полученного результата мы получили контроль обратно и в этот момент мы могли сделать, что то ещё.








