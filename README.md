# asynchrony


### 4_Generators

__Генератор__ - это функция.
   

> ### Пример с перебором букв в слове

```
def gen(name):
    for i in name:
        yield i
        
g = gen('Bob')
next(g)
>>> B
next(g)
>>> o
next(g)
>>> b
next(g)
>>> Error ... StopIteration
```
Как только генератор "истощается/заканчивается" он выбрасывает ошибку.  
     
> ### Пример с созданием папок

```
from time import time

def gen_file_name():
    while True:
        pattern = 'file-{}.jpg'
        t = int(time() * 1000)
        file_name = pattern.format(str(t))
        yield file_name

g = gen_file_name()
next(g)
>>> file-1584695786887.jpg
next(g)
>>> file-1584695786759.jpg
```
В этом примере генератор не закончиться потому, что внутри него крутиться бесконечный цикл _while True_.  
     
> ### Инструкции yield в одной функции-генераторе может быть несколько.

В то время как у _функции_ весь код, который идет после _**return**_ не выполняется. У _генератора_ всё совсем ___не так___.
```
def gen_file_name():
    while True:
        pattern = 'file-{}.jpg'
        t = int(time() * 1000)
        file_name = pattern.format(str(t))
        yield file_name                     # точка остановки

        sum = 123 + 321
        print(sum)
        
g = gen_file_name()
next(g)
>>> file-1584695786887.jpg
next(g)
>>> 444                                     # вот это важный момент
>>> file-1584695786759.jpg
```
Т.е. что получается? При вызове функции next(), генератор отрабатывает до yield (точка остановки) и засыпает. 
После повторного вызова функции next(), оставщаяся часть генератора выполняется, т.е. печатает нам сумму и 
начинается новая итерация цикла.  
   
В одной функции-генераторе может быть сколь угодно ___yield___.
```
def some_yields():
    n = 10
    while True:
        yield n
        yield (n // 10)
        yield (n / 2)
        n += 10

g = some_yields()
next(g)
>>> 10
next(g)
>>> 1
next(g)
>>> 5.0
next(g)             # Вышли из 1-ой итерации цикла и поехали по новой
>>> 20
next(g)
>>> 2
next(g)
>>> 10.0
...
```
     
     
### Событийный цикл _Round Robin_

Мы построили бассейн и в нём нету воды, в то время как у наших соседей в бассейне есть вода. Мы собрали всех друзей, дали каждому
по ведру и построили их в очередь. Первый в очереди зачерпывает воду в ведро, несёт воду к нам в бассейн, вылевает её и встаёт в 
конец очереди. Тот кто был вторым в очереди, становится первым и проделывает тоже самое. И цикличность продолжается пока работа не 
будет выполнена. Вот это и есть _Round Robin, карусель._ 

```
from collections import deque

def gen1(n):
    for i in range(n):
        yield print(i)

def gen2(string):
    for el in string:
        yield print(el)

g1 = gen1(3)
g2 = gen2('Bob')

tasks = deque([g1, g2])                 # deque; Создание новой очереди

while tasks:
    try:
        task = tasks.popleft()
        next(task)
        tasks.append(task)
    except StopIteration:
        pass

>>> 0
>>> B
>>> 1
>>> o
>>> 2
>>> b
```
Суть в том что генераторы выполнялись строго по очереди, каждый раз передавая конкроль туда где вызывалась функция _next_.
После каждого полученного результата мы получили контроль обратно и в этот момент мы могли сделать, что то ещё.








